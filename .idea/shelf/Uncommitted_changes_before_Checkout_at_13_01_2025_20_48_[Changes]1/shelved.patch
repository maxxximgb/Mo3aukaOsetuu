Index: LevelCreatorQT/source.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os\r\nimport shutil\r\nimport sys\r\nfrom qasync import QApplication, QEventLoop, asyncSlot\r\nimport asyncio\r\nfrom PIL import Image, ImageDraw\r\nimport numpy as np\r\nfrom PyQt6 import QtCore\r\nfrom PyQt6.QtCore import Qt, pyqtSignal, QPoint\r\nfrom PyQt6.QtGui import QPixmap, QPainter, QPen, QColor, QKeyEvent, QImage, QIcon\r\nfrom PyQt6.QtWidgets import QMainWindow, QPushButton, QStackedWidget, QWidget, QHBoxLayout, QListWidget, \\\r\n    QLabel, QListWidgetItem, QVBoxLayout, QMessageBox, QFileDialog, QDialog, QLineEdit, QTextEdit, QStackedLayout, \\\r\n    QGridLayout, QProgressBar\r\n\r\ncurrentindexqss = \"\"\"\r\n        QLabel {\r\n            border-radius: 5px;      /* Закругленные углы */\r\n            font-family: \"Arial\";    /* Используем шрифт Arial */\r\n            font-size: 14px;         /* Размер шрифта */\r\n            font-weight: bold;       /* Жирный шрифт */\r\n            background-color: blue;  /* Фон серый при наведении */\r\n        }\r\n        \"\"\"\r\ndefaultqss = \"\"\"\r\n        QLabel {\r\n            border-radius: 5px;      /* Закругленные углы */\r\n            font-family: \"Arial\";    /* Используем шрифт Arial */\r\n            font-size: 14px;         /* Размер шрифта */\r\n            font-weight: bold;       /* Жирный шрифт */\r\n        }\r\n        \r\n        QLabel:hover {\r\n            background-color: gray;  /* Фон серый при наведении */\r\n        }\r\n        \"\"\"\r\n\r\nbuttonqss = \"\"\"\r\n        QPushButton {\r\n            background-color: purple;\r\n            border: none;\r\n            color: white; \r\n            padding: 15px 32px;\r\n            text-align: center;\r\n            font-size: 11px;\r\n            font-weight: bold;\r\n            border-radius: 12px;\r\n            transition: background-color 0.3s ease;\r\n        }\r\n        \r\n        QPushButton:hover {\r\n            background-color: blue;\r\n        }\r\n        \r\n        QPushButton:pressed {\r\n            background-color: black;\r\n        }\r\n        \"\"\"\r\nloadbtnqss = \"\"\"\r\n        QPushButton {\r\n            background-color: #e0e0e0;\r\n            color: black;\r\n            border: 1px solid #808080;\r\n            border-radius: 5px;\r\n            padding: 10px 20px;\r\n            font-weight: bold;\r\n        }\r\n        \r\n        QPushButton:hover {\r\n            background-color: #c0c0c0;\r\n        }\r\n        \r\n        QPushButton:pressed {\r\n            background-color: #a0a0a0;\r\n        }\r\n        \"\"\"\r\nimgqss = \"\"\"\r\n            QLabel {\r\n                border-radius: 10px;\r\n                border: 2px solid black;\r\n                padding: 5px;\r\n            }\r\n            QLabel:hover {\r\n                border-radius: 10px;\r\n                background-color: gray;\r\n            }\r\n        \"\"\"\r\n\r\nAvInd = [1]\r\nlevels = []\r\n\r\n\r\ndef getabspath(path):\r\n    if getattr(sys, 'frozen', False):\r\n        base_path = sys._MEIPASS\r\n    else:\r\n        base_path = os.path.dirname(os.path.abspath(__file__))\r\n\r\n    return os.path.join(base_path, path)\r\n\r\n\r\nclass CentralWidget(QStackedWidget):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.widgets = []\r\n\r\n    def initialize(self):\r\n        self.widgets = [\r\n            Beginning(),\r\n            LoadingMap(),\r\n            CreatingLevels(),\r\n            Finishing()\r\n        ]\r\n        for widget in self.widgets:\r\n            self.addWidget(widget)\r\n        self.setCurrentIndex(0)\r\n\r\n\r\nclass StackedWidget(QWidget):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.index = -1\r\n        self.mlout = QVBoxLayout()\r\n        self.lout = QHBoxLayout()\r\n        self.indexes = QListWidget()\r\n        self.indexes.setSpacing(15)\r\n        self.indexes.setMaximumSize(200, 500)\r\n        self.indexes.setMinimumSize(190, 170)\r\n        self.nextbtn = QPushButton(self)\r\n        self.nextbtn.setStyleSheet(buttonqss)\r\n        self.nextbtn.clicked.connect(self.nextwidget)\r\n        self.nextbtn.setText(\"Далее\")\r\n        self.labels = [QLabel(\" Начало\"),\r\n                       QLabel(\" Загрузка карты\"),\r\n                       QLabel(\" Создание уровней\"),\r\n                       QLabel(\" Сохранение\")]\r\n        [self.addItemToList(l) for l in self.labels]\r\n        self.indexes.itemClicked.connect(self.OIC)\r\n        self.lout.addWidget(self.indexes, alignment=Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignTop)\r\n        self.mlout.addLayout(self.lout)\r\n        self.mlout.addWidget(self.nextbtn, alignment=Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignBottom)\r\n        self.setLayout(self.mlout)\r\n\r\n    def OIC(self, item):\r\n        global AvInd\r\n        index = self.indexes.row(item)\r\n        if index < self.index:\r\n            self.parent().setCurrentIndex(index)\r\n        elif index in AvInd:\r\n            self.parent().setCurrentIndex(index)\r\n        else:\r\n            self.showMbox()\r\n\r\n    def showMbox(self):\r\n        box = QMessageBox(self, icon=QMessageBox.Icon.Warning, text=\"Заполните значения в предыдущих окнах!\")\r\n        box.setWindowFlags(Qt.WindowType.Window | Qt.WindowType.CustomizeWindowHint)\r\n        box.exec()\r\n\r\n    def addItemToList(self, a):\r\n        a.setStyleSheet(defaultqss)\r\n        item = QListWidgetItem()\r\n        self.indexes.addItem(item)\r\n        self.indexes.setItemWidget(item, a)\r\n\r\n    def nextwidget(self):\r\n        if self.index + 1 not in AvInd:\r\n            box = QMessageBox(self, icon=QMessageBox.Icon.Warning, text=\"Не все поля заполнены!\")\r\n            box.setWindowFlags(Qt.WindowType.Window | Qt.WindowType.CustomizeWindowHint)\r\n            box.exec()\r\n            return\r\n        self.parent().setCurrentIndex(self.index + 1)\r\n        if self.index + 1 not in AvInd: AvInd.append(self.index + 1)\r\n\r\n\r\nclass Beginning(StackedWidget):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.index = 0\r\n        self.indexes.itemWidget(self.indexes.item(self.index)).setStyleSheet(currentindexqss)\r\n        self.label = QLabel(\r\n            \"Здравствуйте! Cейчас мы поможем Вам создать уровни для игры 'Мозаика Осетии'.\\n\"\r\n            \"Для того, чтобы приступить, нажмите на кнопку Далее, или выберите слева второй пункт.\")\r\n        self.label.setStyleSheet(\"\"\"\r\n        QLabel {\r\n            font-size: 25px;\r\n        }\r\n        \"\"\")\r\n        self.lout.addWidget(self.label, alignment=Qt.AlignmentFlag.AlignTop)\r\n\r\n\r\nclass LoadingMap(StackedWidget):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.index = 1\r\n        self.pixmap = QPixmap()\r\n        self.imagelabel = QLabel()\r\n        self.indexes.itemWidget(self.indexes.item(self.index)).setStyleSheet(currentindexqss)\r\n        self.imagelout = QVBoxLayout()\r\n        self.selectMapBtn = QPushButton(text=\"Загрузить\")\r\n        self.selectMapBtn.setStyleSheet(loadbtnqss)\r\n        self.selectMapBtn.clicked.connect(self.selectImage)\r\n        self.imagelout.addWidget(self.imagelabel, alignment=Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignCenter)\r\n        self.imagelout.addWidget(self.selectMapBtn, alignment=Qt.AlignmentFlag.AlignCenter)\r\n        self.imagelout.addWidget(QLabel(text=\"Загрузите карту для уровня.\\n\"\r\n                                             \"Нажмите на кнопку Загрузить и укажите путь к вашей карте.\"),\r\n                                 alignment=Qt.AlignmentFlag.AlignCenter)\r\n        self.imagelout.itemAt(2).widget().setStyleSheet(\"\"\"\r\n        QLabel {\r\n            font-size: 15px;\r\n        }\r\n        \"\"\")\r\n        self.lout.addLayout(self.imagelout)\r\n        self.loadImage(getabspath(\"Preview.jpg\"))\r\n\r\n    def loadImage(self, path):\r\n        self.pixmap.load(getabspath(path))\r\n        self.imagelabel.setPixmap(self.pixmap)\r\n        global levels\r\n        levels.clear()\r\n\r\n    def selectImage(self):\r\n        path, _ = QFileDialog.getOpenFileName(self, \"Выберите изображение\", \"\",\r\n                                              \"Images (*.bmp *.gif *.jpg *.jpeg *.png *.pbm *.pgm *.ppm *.xbm *.xpm)\")\r\n        if path:\r\n            self.loadImage(path)\r\n            global AvInd\r\n            if self.index + 1 not in AvInd: AvInd.append(self.index + 1)\r\n            self.parent().widgets[2].setImage(self.pixmap)\r\n\r\n\r\nclass CreatingLevels(StackedWidget):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.index = 2\r\n        self.indexes.itemWidget(self.indexes.item(self.index)).setStyleSheet(currentindexqss)\r\n        self.imagelout = QVBoxLayout()\r\n        self.setMouseTracking(True)\r\n        self.imagelabel = MapLabel()\r\n        self.imagetext = QLabel(text=\"Выберите точки на карте, где будут находиться города.\\n\"\r\n                                     \"Для этого щелкните мышкой по нужным вам точкам на карте.\\n\"\r\n                                     \"Первая отмеченая точка будет не игровой и будет являться точкой старта пользователя.\\n\"\r\n                                     \"Типа въезд в город.\\n\"\r\n                                     \"Для удаления точки наведите на нее курсор и нажмите delete.\\n\"\r\n                                     \"Нажмите еще раз на созданную точку чтобы открыть меню её редактирования.\")\r\n        self.imagetext.setStyleSheet(\"\"\"\r\n        QLabel {\r\n            font-size: 15px;\r\n        }\r\n        \"\"\")\r\n        self.imagelout.addWidget(self.imagelabel, alignment=Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignCenter)\r\n        self.imagelout.addWidget(self.imagetext, alignment=Qt.AlignmentFlag.AlignCenter)\r\n        self.lout.addLayout(self.imagelout)\r\n\r\n    def mousePressEvent(self, a0):\r\n        if self.imagelabel.geometry().contains(a0.position().toPoint()):\r\n            local_pos = self.imagelabel.mapFromGlobal(a0.globalPosition().toPoint())\r\n            global levels\r\n            for level in levels:\r\n                posi = level[0]\r\n                if abs(posi.x() - local_pos.x()) < 10 and abs(posi.y() - local_pos.y()) < 10:\r\n                    print(levels.index(level))\r\n                    if levels.index(level) == 0:\r\n                        return\r\n                    data = LevelRedactor(level[1]).execute()\r\n                    if data is not None:\r\n                        level[1] = data\r\n                    self.imagelabel.update()\r\n                    return\r\n\r\n            levels.append([local_pos, LevelData()])\r\n            if len(levels) > 1 and 3 not in AvInd:\r\n                AvInd.append(3)\r\n            elif len(levels) < 2 and 3 in AvInd:\r\n                AvInd.remove(3)\r\n            self.imagelabel.update()\r\n\r\n    def keyPressEvent(self, event):\r\n        if event.key() == Qt.Key.Key_Delete:\r\n            global levels\r\n            mouse_pos = self.imagelabel.mapFromGlobal(self.cursor().pos())\r\n            for posi in levels:\r\n                pos = posi[0]\r\n                if abs(pos.x() - mouse_pos.x()) < 10 and abs(pos.y() - mouse_pos.y()) < 10:\r\n                    levels.remove(posi)\r\n                    self.imagelabel.update()\r\n                    if len(levels[1:]) == 0 and 3 in AvInd: AvInd.remove(3)\r\n                    return\r\n\r\n    def setImage(self, pixmap):\r\n        self.imagelabel.setPixmap(pixmap)\r\n        self.imagelabel.ispixmap = True\r\n\r\n\r\nclass MapLabel(QLabel):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.ispixmap = False\r\n        self.setMouseTracking(True)\r\n\r\n    def paintEvent(self, event):\r\n        super().paintEvent(event)\r\n        global levels\r\n        if not self.ispixmap: return\r\n        if not levels: return\r\n        redPen = QColor(255, 0, 0)\r\n        bluePen = QColor(0, 0, 255)\r\n        greenPen = QColor(0, 255, 0)\r\n        yellowPen = QColor(255, 255, 0)\r\n        painter = QPainter(self)\r\n        painter.setPen(bluePen)\r\n        painter.setBrush(bluePen)\r\n        painter.drawEllipse(levels[0][0], 10, 10)\r\n\r\n        for level in levels[1::]:\r\n            pos = level[0]\r\n            if level[1].isFilled == 1:\r\n                painter.setPen(greenPen)\r\n                painter.setBrush(greenPen)\r\n            elif level[1].isFilled == 2:\r\n                painter.setPen(yellowPen)\r\n                painter.setBrush(yellowPen)\r\n            else:\r\n                painter.setPen(redPen)\r\n                painter.setBrush(redPen)\r\n            painter.drawEllipse(pos, 10, 10)\r\n\r\n    def mouseMoveEvent(self, event):\r\n        global levels\r\n        mouse_pos = self.mapFromGlobal(self.cursor().pos())\r\n        for pos in levels:\r\n            pos = pos[0]\r\n            if abs(pos.x() - mouse_pos.x()) < 10 and abs(pos.y() - mouse_pos.y()) < 10:\r\n                self.setCursor(Qt.CursorShape.PointingHandCursor)\r\n                return\r\n\r\n        self.setCursor(Qt.CursorShape.ArrowCursor)\r\n\r\n\r\nclass LevelData:\r\n    def __init__(self):\r\n        self.isFilled = 0\r\n        self.images = []\r\n        self.name = ''\r\n        self.desc = ''\r\n        self.memorials = []\r\n\r\n\r\nclass Memorial:\r\n    def __init__(self, preview):\r\n        self.isFilled = False\r\n        self.preview = preview\r\n        self.images = []\r\n        self.name = ''\r\n        self.desc = ''\r\n        self.puzzleparts = []\r\n        self.puzzle = None\r\n\r\n\r\nclass LevelEditorWidget(QWidget):\r\n    def __init__(self, LevelData):\r\n        super().__init__()\r\n        self.levelData = LevelData\r\n        self.nextbtn = QPushButton(text=\"Далее\")\r\n        self.nextbtn.setStyleSheet(buttonqss)\r\n        self.nextbtn.setFixedSize(100, 50)\r\n        self.nextbtn.clicked.connect(self.saveData)\r\n        self.images = [[DClickImgLabel(), QPixmap(), False] for _ in range(4)]\r\n        self.lout = QHBoxLayout()\r\n        self.objlout = QVBoxLayout()\r\n        self.mimageslout = QVBoxLayout()\r\n        self.imagelout1 = QHBoxLayout()\r\n        self.imagelout2 = QHBoxLayout()\r\n        self.nameinput = QLineEdit()\r\n        self.descinput = QTextEdit()\r\n        self.nameinput.setPlaceholderText(\"Введите название обьекта\")\r\n        self.descinput.setPlaceholderText(\"Введите описание обьекта\")\r\n        self.objlout.addWidget(self.nameinput)\r\n        self.objlout.addWidget(self.descinput)\r\n        self.objlout.addWidget(self.nextbtn, alignment=Qt.AlignmentFlag.AlignRight)\r\n        for i in range(2):\r\n            self.imagelout1.addWidget(self.images[i][0], alignment=Qt.AlignmentFlag.AlignLeft)\r\n            self.imagelout2.addWidget(self.images[i + 2][0], alignment=Qt.AlignmentFlag.AlignLeft)\r\n            self.images[i][0].hide()\r\n            self.images[i + 2][0].hide()\r\n\r\n        self.images[0][0].show()\r\n        self.mimageslout.addLayout(self.imagelout1)\r\n        self.mimageslout.addLayout(self.imagelout2)\r\n        self.textlabel = QLabel(text=\"Загрузите фотографии обьекта 16:9, нажав на выделенное изображение сверху.\\n\"\r\n                                     \"Максимум изображений: 4\")\r\n        self.textlabel.setStyleSheet(\"\"\"\r\n            QLabel {\r\n                font-size: 15px;\r\n            }\r\n        \"\"\")\r\n        self.textlabel.setMinimumWidth(500)\r\n        self.textlabel.setWordWrap(True)\r\n\r\n        self.mimageslout.addWidget(self.textlabel, alignment=Qt.AlignmentFlag.AlignLeft)\r\n        self.lout.addLayout(self.mimageslout)\r\n        self.lout.addLayout(self.objlout)\r\n        self.setLayout(self.lout)\r\n        self.loadData()\r\n\r\n    def addImage(self, image, type=\"file\"):\r\n        for img in self.images:\r\n            if not img[2]:\r\n                if type == \"file\":\r\n                    img[1].load(image)\r\n                elif type == \"buffer\":\r\n                    img[1].loadFromData(image)\r\n                img[1] = img[1].scaled(300, 150, Qt.AspectRatioMode.KeepAspectRatio,\r\n                                       Qt.TransformationMode.SmoothTransformation)\r\n                img[0].setPixmap(img[1])\r\n                img[0].setFixedSize(img[1].size())\r\n                img[2] = True\r\n                img[0].setAlignment(Qt.AlignmentFlag.AlignLeft)\r\n                img[0].show()\r\n                if self.images.index(img) == 3:\r\n                    img[0].setStyleSheet(\"\")\r\n                else:\r\n                    img[0].clicked.connect(self.selectImage)\r\n                break\r\n            else:\r\n                if img[0].styleSheet():\r\n                    img[0].clicked.disconnect()\r\n                    img[0].setStyleSheet(\"\")\r\n\r\n    def selectImage(self):\r\n        path, _ = QFileDialog.getOpenFileName(self, \"Выберите изображение\", \"\",\r\n                                              \"Images (*.bmp *.gif *.jpg *.jpeg *.png *.pbm *.pgm *.ppm *.xbm *.xpm)\")\r\n        if path:\r\n            self.addImage(path)\r\n\r\n    def loadData(self):\r\n        if not self.levelData.isFilled:\r\n            self.addImage(getabspath(\"add.png\"))\r\n            self.images[0][2] = False\r\n        else:\r\n            for img in self.levelData.images:\r\n                self.addImage(img, type=\"buffer\")\r\n            self.nameinput.setText(self.levelData.name)\r\n            self.descinput.setText(self.levelData.desc)\r\n\r\n    def saveData(self):\r\n        isPixmap = any([pixmap[2] for pixmap in self.images])\r\n        isDesc = self.descinput.toPlainText()\r\n        isName = self.nameinput.text()\r\n\r\n        if not isPixmap:\r\n            self.images[0][0].setStyleSheet(imgqss.replace(\"black\", \"red\"))\r\n        if not isName:\r\n            self.nameinput.setStyleSheet(\"\"\"\r\n            QLineEdit {\r\n                border: 2px solid red;\r\n                border-radius: 4px;\r\n            }\r\n            \"\"\")\r\n            self.nameinput.textChanged.connect(lambda: self.nameinput.setStyleSheet(\"\"))\r\n        if not isDesc:\r\n            self.descinput.setStyleSheet(\"\"\"\r\n            QTextEdit {\r\n                border: 2px solid red;\r\n                padding: 2px;\r\n                border-radius: 4px;\r\n            }\r\n            \"\"\")\r\n            self.descinput.textChanged.connect(lambda: self.descinput.setStyleSheet(\"\"))\r\n\r\n        if all([isPixmap, isName, isDesc]):\r\n            self.levelData.images.clear()\r\n            for image in self.images:\r\n                if image[2]:\r\n                    pixmap = image[1]\r\n                    buffer = QtCore.QBuffer()\r\n                    buffer.open(QtCore.QIODevice.OpenModeFlag.ReadWrite)\r\n                    pixmap.save(buffer, \"PNG\")\r\n                    self.levelData.images.append(buffer.data())\r\n                    buffer.close()\r\n\r\n            self.levelData.name = isName\r\n            self.levelData.desc = isDesc\r\n            if self.levelData.isFilled != 1:\r\n                self.levelData.isFilled = 2\r\n            self.parent().stackedLayout.setCurrentIndex(1)\r\n\r\n\r\nclass MemorialSelectorWidget(QWidget):\r\n    def __init__(self, LevelData):\r\n        super().__init__()\r\n        self.lout = QVBoxLayout()\r\n        self.grid_layout = QGridLayout()\r\n        self.backBtn = QPushButton(text='Назад')\r\n        self.saveBtn = QPushButton(text=\"Сохранить\")\r\n        self.btnLayout = QHBoxLayout()\r\n        self.saveBtn.clicked.connect(self.saveData)\r\n        self.saveBtn.setStyleSheet(buttonqss)\r\n        self.backBtn.setStyleSheet(buttonqss)\r\n        self.backBtn.clicked.connect(lambda: self.parent().stackedLayout.setCurrentIndex(0))\r\n        self.btnLayout.addWidget(self.backBtn, alignment=Qt.AlignmentFlag.AlignRight)\r\n        self.btnLayout.addWidget(self.saveBtn, alignment=Qt.AlignmentFlag.AlignRight)\r\n        self.btnLayout.setSpacing(3)\r\n        self.levelData = LevelData\r\n        self.memorials = []\r\n        self.label = QLabel('Добавьте мемориалы выбранного города')\r\n        self.label.setStyleSheet(defaultqss)\r\n        self.lout.addWidget(self.label, alignment=Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignCenter)\r\n        self.lout.addLayout(self.grid_layout)\r\n        self.lout.addLayout(self.btnLayout)\r\n        self.btnLayout.setAlignment(Qt.AlignmentFlag.AlignRight)\r\n        self.setLayout(self.lout)\r\n        self.loadData()\r\n\r\n    def addImage(self, image, type=\"file\"):\r\n        pixmap = QPixmap()\r\n        label = DClickImgLabel()\r\n        pixmap.loadFromData(image.preview) if type == \"class\" else pixmap.load(image)\r\n        pixmap = pixmap.scaled(400, 300, Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation)\r\n        if not self.memorials:\r\n            label.setPixmap(pixmap)\r\n            self.memorials.append([label, Memorial(image) if type == 'file' else image, False])\r\n        else:\r\n            for i, (label, memorial, is_temp) in enumerate(self.memorials):\r\n                if is_temp:\r\n                    label.setPixmap(pixmap)\r\n                    if type == 'file':\r\n                        buffer = QtCore.QBuffer()\r\n                        buffer.open(QtCore.QIODevice.OpenModeFlag.ReadWrite)\r\n                        pixmap.save(buffer, \"PNG\")\r\n                        image = buffer.data()\r\n                        buffer.close()\r\n\r\n                    self.memorials[i][1:] = Memorial(image) if type == 'file' else image, False\r\n                    self.memorials[i][0].clicked.disconnect()\r\n                    self.memorials[i][0].clicked.connect(lambda: MemorialEditorWidget(self.memorials[i][1]).exec())\r\n\r\n        self.addTempImage()\r\n\r\n    def addTempImage(self):\r\n        img_label = DClickImgLabel()\r\n        pixmap = QPixmap(getabspath(\"addmem.png\"))\r\n        pixmap = pixmap.scaled(400, 300, Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation)\r\n        img_label.setPixmap(pixmap)\r\n        img_label.show()\r\n        self.memorials.append([img_label, pixmap, True])\r\n        row = (len(self.memorials) - 1) // 2\r\n        col = (len(self.memorials) - 1) % 2\r\n        self.grid_layout.addWidget(img_label, row, col,\r\n                                   alignment=Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignTop)\r\n        img_label.clicked.connect(self.selectImage)\r\n\r\n    def loadData(self):\r\n        self.addTempImage()\r\n        if self.levelData.memorials:\r\n            for memorial in self.levelData.memorials:\r\n                self.addImage(memorial, type=\"class\")\r\n\r\n    def selectImage(self):\r\n        path, _ = QFileDialog.getOpenFileName(self, \"Выберите изображение\", \"\",\r\n                                              \"Images (*.bmp *.gif *.jpg *.jpeg *.png *.pbm *.pgm *.ppm *.xbm *.xpm)\")\r\n        if path:\r\n            self.addImage(path)\r\n\r\n    def saveData(self):\r\n        fl = False\r\n        if len(self.memorials) == 1:\r\n            self.memorials[0][0].setStyleSheet(imgqss.replace(\"black\", \"red\"))\r\n            return\r\n        for memorial in self.memorials:\r\n            if memorial[2]: continue\r\n            if not memorial[1].isFilled:\r\n                fl = True\r\n                memorial[0].setStyleSheet(imgqss.replace(\"black\", \"red\"))\r\n        if fl: return\r\n        self.levelData.memorials = [m[1] for m in self.memorials if m[2] != True]\r\n        self.levelData.isFilled = 1\r\n        self.parent().close()\r\n\r\n\r\nclass MemorialEditorWidget(QDialog):\r\n    def __init__(self, memorial):\r\n        super().__init__()\r\n        self.setWindowTitle(\"Редактор данных мемориала\")\r\n        self.memorial = memorial\r\n        self.savebtn = QPushButton(text=\"Сохранить\")\r\n        self.savebtn.setStyleSheet(buttonqss)\r\n        self.savebtn.setFixedSize(150, 50)\r\n        self.savebtn.clicked.connect(self.saveData)\r\n        self.images = [[DClickImgLabel(), QPixmap(), False] for _ in range(4)]\r\n        self.lout = QHBoxLayout()\r\n        self.objlout = QVBoxLayout()\r\n        self.mimageslout = QVBoxLayout()\r\n        self.imagelout1 = QHBoxLayout()\r\n        self.imagelout2 = QHBoxLayout()\r\n        self.nameinput = QLineEdit()\r\n        self.descinput = QTextEdit()\r\n        self.puzzle = QPixmap()\r\n        self.puzzlepartl = DClickImgLabel()\r\n        self.puzzlepartl.setPixmap(self.puzzle)\r\n        self.puzzlepartl.clicked.connect(lambda: self.selectImage(type='puzzle'))\r\n        self.nameinput.setPlaceholderText(\"Введите название мемориала\")\r\n        self.descinput.setPlaceholderText(\"Введите описание мемориала\")\r\n        self.objlout.addWidget(self.nameinput)\r\n        self.objlout.addWidget(self.descinput)\r\n        self.objlout.addWidget(self.savebtn, alignment=Qt.AlignmentFlag.AlignRight)\r\n        for i in range(2):\r\n            self.imagelout1.addWidget(self.images[i][0], alignment=Qt.AlignmentFlag.AlignLeft)\r\n            self.imagelout2.addWidget(self.images[i + 2][0], alignment=Qt.AlignmentFlag.AlignLeft)\r\n            self.images[i][0].hide()\r\n            self.images[i + 2][0].hide()\r\n\r\n        self.images[0][0].show()\r\n        self.mimageslout.addLayout(self.imagelout1)\r\n        self.mimageslout.addLayout(self.imagelout2)\r\n        self.textlabel = QLabel(text=\"Загрузите фотографии мемориала 16:9, нажав на выделенное изображение сверху.\\n\"\r\n                                     \"Максимум изображений: 4\")\r\n        self.textlabel.setStyleSheet(\"\"\"\r\n            QLabel {\r\n                font-size: 15px;\r\n            }\r\n        \"\"\")\r\n        self.textlabel.setMinimumWidth(500)\r\n        self.textlabel.setWordWrap(True)\r\n        self.puzzletextl = QLabel('Загрузите изображение, которое будет раздроблено на пазл мемориала')\r\n        self.puzzletextl.setStyleSheet(\"\"\"\r\n            QLabel {\r\n                font-size: 15px;\r\n            }\r\n        \"\"\")\r\n        self.mimageslout.addWidget(self.textlabel, alignment=Qt.AlignmentFlag.AlignLeft)\r\n        self.mimageslout.addWidget(self.puzzletextl)\r\n        self.mimageslout.addWidget(self.puzzlepartl)\r\n        self.lout.addLayout(self.mimageslout)\r\n        self.lout.addLayout(self.objlout)\r\n        self.setLayout(self.lout)\r\n        self.loadData()\r\n\r\n    def addImage(self, image, type=\"file\"):\r\n        for img in self.images:\r\n            if not img[2]:\r\n                if type == \"file\":\r\n                    img[1].load(image)\r\n                elif type == \"buffer\":\r\n                    img[1].loadFromData(image)\r\n                img[1] = img[1].scaled(300, 150, Qt.AspectRatioMode.KeepAspectRatio,\r\n                                       Qt.TransformationMode.SmoothTransformation)\r\n                img[0].setPixmap(img[1])\r\n                img[0].setFixedSize(img[1].size())\r\n                img[2] = True\r\n                img[0].setAlignment(Qt.AlignmentFlag.AlignLeft)\r\n                img[0].show()\r\n                if self.images.index(img) == 3:\r\n                    img[0].setStyleSheet(\"\")\r\n                else:\r\n                    img[0].clicked.connect(self.selectImage)\r\n                break\r\n            else:\r\n                if img[0].styleSheet():\r\n                    img[0].clicked.disconnect()\r\n                    img[0].setStyleSheet(\"\")\r\n\r\n    def selectImage(self, type='default'):\r\n        path, _ = QFileDialog.getOpenFileName(self, \"Выберите изображение\", \"\",\r\n                                              \"Images (*.bmp *.gif *.jpg *.jpeg *.png *.pbm *.pgm *.ppm *.xbm *.xpm)\")\r\n        if not path: return\r\n        if type == 'puzzle':\r\n            self.loadpuzzle(path)\r\n            return\r\n        if path:\r\n            self.addImage(path)\r\n\r\n    def loadpuzzle(self, file, type='file'):\r\n        if type == 'file':\r\n            self.puzzle.load(file)\r\n            self.puzzle = self.puzzle.scaled(1500, 1500, Qt.AspectRatioMode.KeepAspectRatio,\r\n                                             Qt.TransformationMode.SmoothTransformation)\r\n            buffer = QtCore.QBuffer()\r\n            buffer.open(QtCore.QIODevice.OpenModeFlag.ReadWrite)\r\n            self.puzzle.save(buffer, \"PNG\")\r\n            self.memorial.puzzle = buffer.data()\r\n            buffer.close()\r\n\r\n        else:\r\n            self.puzzle.loadFromData(file)\r\n\r\n        self.puzzle = self.puzzle.scaled(600, 600, Qt.AspectRatioMode.KeepAspectRatio,\r\n                                         Qt.TransformationMode.SmoothTransformation)\r\n        self.puzzlepartl.setPixmap(self.puzzle)\r\n        self.puzzlepartl.setFixedSize(self.puzzle.size())\r\n\r\n    def loadData(self):\r\n        if not self.memorial.isFilled:\r\n            self.addImage(getabspath(\"add.png\"))\r\n            self.puzzle.load(getabspath(\"addmem.png\"))\r\n            self.puzzle = self.puzzle.scaled(400, 400, Qt.AspectRatioMode.KeepAspectRatio,\r\n                                             Qt.TransformationMode.SmoothTransformation)\r\n            self.puzzlepartl.setPixmap(self.puzzle)\r\n            self.puzzlepartl.setFixedSize(400, 400)\r\n            self.images[0][2] = False\r\n        else:\r\n            for img in self.memorial.images:\r\n                self.addImage(img, type=\"buffer\")\r\n            self.loadpuzzle(self.memorial.puzzle, type='image')\r\n            self.nameinput.setText(self.memorial.name)\r\n            self.descinput.setText(self.memorial.desc)\r\n\r\n    def saveData(self):\r\n        isPixmap = any([pixmap[2] for pixmap in self.images])\r\n        isDesc = self.descinput.toPlainText()\r\n        isName = self.nameinput.text()\r\n        isPuzzle = self.memorial.puzzle\r\n\r\n        if not isPixmap:\r\n            self.images[0][0].setStyleSheet(imgqss.replace(\"black\", \"red\"))\r\n        if not isName:\r\n            self.nameinput.setStyleSheet(\"\"\"\r\n            QLineEdit {\r\n                border: 2px solid red;\r\n                border-radius: 4px;\r\n            }\r\n            \"\"\")\r\n            self.nameinput.textChanged.connect(lambda: self.nameinput.setStyleSheet(\"\"))\r\n        if not isDesc:\r\n            self.descinput.setStyleSheet(\"\"\"\r\n            QTextEdit {\r\n                border: 2px solid red;\r\n                padding: 2px;\r\n                border-radius: 4px;\r\n            }\r\n            \"\"\")\r\n            self.descinput.textChanged.connect(lambda: self.descinput.setStyleSheet(\"\"))\r\n        if not isPuzzle:\r\n            self.puzzlepartl.setStyleSheet(imgqss.replace(\"black\", \"red\"))\r\n\r\n        if all([isPixmap, isName, isDesc, isPuzzle]):\r\n            self.memorial.images.clear()\r\n            for image in self.images:\r\n                if image[2]:\r\n                    pixmap = image[1]\r\n                    buffer = QtCore.QBuffer()\r\n                    buffer.open(QtCore.QIODevice.OpenModeFlag.ReadWrite)\r\n                    pixmap.save(buffer, \"PNG\")\r\n                    self.memorial.images.append(buffer.data())\r\n                    buffer.close()\r\n\r\n            self.memorial.puzzleparts = self.bytesToPuzzle(self.memorial.puzzle)\r\n            self.memorial.name = isName\r\n            self.memorial.desc = isDesc\r\n            self.memorial.isFilled = True\r\n            self.close()\r\n\r\n    def bytesToPuzzle(self, bytes):\r\n        image = QImage()\r\n        image.loadFromData(bytes)\r\n        pixmap = QPixmap.fromImage(image)\r\n        width = pixmap.width()\r\n        height = pixmap.height()\r\n\r\n        min_grid_size = 15\r\n        max_grid_size = 25\r\n\r\n        aspect_ratio = width / height\r\n        if aspect_ratio > 1:\r\n            cols = min(max_grid_size, max(min_grid_size, int((width / height) * min_grid_size)))\r\n            rows = min(max_grid_size, max(min_grid_size, int(min_grid_size / (width / height))))\r\n        else:\r\n            rows = min(max_grid_size, max(min_grid_size, int((height / width) * min_grid_size)))\r\n            cols = min(max_grid_size, max(min_grid_size, int(min_grid_size / (height / width))))\r\n\r\n        rows = min(rows, height)\r\n        cols = min(cols, width)\r\n        piece_width = width // cols\r\n        piece_height = height // rows\r\n        puzzle_matrix = np.empty((rows, cols), dtype=object)\r\n\r\n        for i in range(rows):\r\n            for j in range(cols):\r\n                piece = pixmap.copy(j * piece_width, i * piece_height, piece_width, piece_height)\r\n                qimage = piece.toImage()\r\n                pil_image = Image.fromqimage(qimage)\r\n                puzzle_matrix[i, j] = pil_image\r\n\r\n        return puzzle_matrix\r\n\r\n\r\nclass LevelRedactor(QDialog):\r\n    def __init__(self, LevelData):\r\n        super().__init__()\r\n        self.levelData = LevelData\r\n        self.setWindowTitle(\"Редактирование данных уровня\")\r\n        self.resize(900, 400)\r\n\r\n        self.stackedLayout = QStackedLayout()\r\n        self.setLayout(self.stackedLayout)\r\n\r\n        self.levelEditorWidget = LevelEditorWidget(self.levelData)\r\n        self.memorialSelectorWidget = MemorialSelectorWidget(self.levelData)\r\n        self.stackedLayout.addWidget(self.levelEditorWidget)\r\n        self.stackedLayout.addWidget(self.memorialSelectorWidget)\r\n\r\n    def execute(self):\r\n        self.exec()\r\n        return self.levelData if self.levelData.isFilled > 0 else None\r\n\r\n\r\nclass Finishing(StackedWidget):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.index = 3\r\n        self.indexes.itemWidget(self.indexes.item(self.index)).setStyleSheet(currentindexqss)\r\n        self.nextbtn.hide()\r\n        self.vlayout = QVBoxLayout()\r\n        self.lout.addLayout(self.vlayout)\r\n        self.label = QLabel(\"Укажите путь для сохранения уровня\")\r\n        self.label.setStyleSheet(\"\"\"\r\n        QLabel {\r\n            font-size: 25px;\r\n        }\r\n        \"\"\")\r\n        self.vlayout.addWidget(self.label)\r\n        self.sw = None\r\n        self.path_layout = QHBoxLayout()\r\n        self.path_line_edit = QLineEdit(self)\r\n        self.path_line_edit.setPlaceholderText(\"Выберите путь для сохранения\")\r\n        self.path_line_edit.setReadOnly(True)\r\n        self.path_line_edit.setStyleSheet(\"\"\"\r\n            QLineEdit {\r\n                padding: 8px;\r\n                border: 2px solid #ccc;\r\n                border-radius: 5px;\r\n                font-size: 14px;\r\n            }\r\n            QLineEdit:focus {\r\n                border-color: #6a9eda;\r\n            }\r\n        \"\"\")\r\n        self.path_layout.addWidget(self.path_line_edit)\r\n        self.select_path_button = QPushButton(self)\r\n        self.select_path_button.setIcon(QIcon.fromTheme(\"folder\"))\r\n        self.select_path_button.setStyleSheet(\"\"\"\r\n            QPushButton {\r\n                background-color: #6a9eda;\r\n                border: none;\r\n                border-radius: 5px;\r\n                padding: 8px;\r\n                min-width: 40px;\r\n            }\r\n            QPushButton:hover {\r\n                background-color: #5a8ec9;\r\n            }\r\n            QPushButton:pressed {\r\n                background-color: #4a7db9;\r\n            }\r\n        \"\"\")\r\n        self.select_path_button.clicked.connect(self.show_file_dialog)\r\n        self.path_layout.addWidget(self.select_path_button)\r\n        self.vlayout.addLayout(self.path_layout)\r\n        self.vlayout.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)\r\n        self.saveBtn = QPushButton(text='Сохранить')\r\n        self.saveBtn.clicked.connect(self.check)\r\n        self.saveBtn.setStyleSheet(buttonqss)\r\n        self.vlayout.addWidget(self.saveBtn, alignment=Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignBottom)\r\n\r\n    def show_file_dialog(self):\r\n        path, _ = QFileDialog.getSaveFileName(self, \"Выберите путь для сохранения\", \"\", \"Файлы уровней (*.level)\")\r\n\r\n        if path:\r\n            self.path_line_edit.setText(path)\r\n\r\n    def check(self):\r\n        if not self.path_line_edit.text():\r\n            self.path_line_edit.setStyleSheet(\"\"\"\r\n                QLineEdit {\r\n                    padding: 8px;\r\n                    border: 2px solid red;\r\n                    border-radius: 5px;\r\n                    font-size: 14px;\r\n                }\r\n                QLineEdit:focus {\r\n                    border-color: red;\r\n                }\r\n            \"\"\")\r\n            self.path_line_edit.textChanged.connect(lambda: self.path_line_edit.setStyleSheet(\"\"\"\r\n                QLineEdit {\r\n                    padding: 8px;\r\n                    border: 2px solid #ccc;\r\n                    border-radius: 5px;\r\n                    font-size: 14px;\r\n                }\r\n                QLineEdit:focus {\r\n                    border-color: #6a9eda;\r\n                }\r\n            \"\"\"))\r\n            return\r\n\r\n        global window\r\n        window.hide()\r\n        self.sw = SaveWidget(self.path_line_edit.text())\r\n        r = self.sw.checkAndSave()\r\n        if not r: window.show()\r\n\r\n\r\nclass SaveWidget(QWidget):\r\n    def __init__(self, directory):\r\n        super().__init__()\r\n        self.dir = directory\r\n        self.setWindowTitle('Выполняется сохранение')\r\n        self.lout = QVBoxLayout()\r\n        self.donelout = QVBoxLayout()\r\n        self.progressbar = QProgressBar()\r\n        self.progresslabel = QLabel()\r\n        self.lout.addWidget(self.progresslabel, alignment=Qt.AlignmentFlag.AlignCenter)\r\n        self.lout.addWidget(self.progressbar, alignment=Qt.AlignmentFlag.AlignCenter)\r\n        self.donelabel = QLabel(\r\n            text='Поздравляем, вы успешно создали уровень. Он находится в указаной вами папке. Спасибо за использование программы! Для повторного использования перезапустите программу. Автоматический выход через 10 секунд.')\r\n        self.donelout.addWidget(self.donelabel)\r\n        self.exitbtn = QPushButton(text='Выход')\r\n        self.donelout.addWidget(self.exitbtn)\r\n        self.exitbtn.clicked.connect(os.abort)\r\n        self.setStyleSheet(\"\"\"\r\n            QWidget {\r\n                background-color: #2E3440;\r\n                color: #D8DEE9;\r\n                font-size: 16px;\r\n            }\r\n            QProgressBar {\r\n                background-color: #4C566A;\r\n                color: #D8DEE9;\r\n                border: 2px solid #5E81AC;\r\n                border-radius: 5px;\r\n                text-align: center;\r\n                height: 30px;\r\n            }\r\n            QProgressBar::chunk {\r\n                background-color: #81A1C1;\r\n                border-radius: 3px;\r\n            }\r\n            QLabel {\r\n                color: #ECEFF4;\r\n                font-size: 18px;\r\n            }\r\n            QPushButton {\r\n                background-color: #4C566A;\r\n                color: #ECEFF4;\r\n                border: 2px solid #5E81AC;\r\n                border-radius: 5px;\r\n                padding: 10px 20px;\r\n                font-size: 16px;\r\n                font-weight: bold;\r\n            }\r\n            QPushButton:hover {\r\n                background-color: #5E81AC;\r\n                border: 2px solid #81A1C1;\r\n            }\r\n            QPushButton:pressed {\r\n                background-color: #81A1C1;\r\n                border: 2px solid #4C566A;\r\n            }\r\n        \"\"\")\r\n        self.setLayout(self.lout)\r\n\r\n    def checkAndSave(self):\r\n        global levels\r\n        if not levels:\r\n            QMessageBox(QMessageBox.Icon.Critical, 'Нечего сохранять', 'Вам нечего сохранять! Уровни не созданы!',\r\n                        QMessageBox.StandardButton.Ok).exec()\r\n            return False\r\n        nfl = 0\r\n        for level in levels[1:]:\r\n            print(level)\r\n            if level[1].isFilled != 1:\r\n                nfl += 1\r\n        if nfl > 0:\r\n            QMessageBox(QMessageBox.Icon.Warning, 'Некоторые уровни не заполнены!',\r\n                        'Некоторые уровни не заполнены или заполнены не до конца!\\nПроверьте карту в третьем пункте на наличие желтых или красных кружков.\\nЗаполните их или удалите. ',\r\n                        QMessageBox.StandardButton.Ok).exec()\r\n            return False\r\n        asyncio.ensure_future(self.save())\r\n        return True\r\n\r\n    @asyncSlot()\r\n    async def save(self):\r\n        self.show()\r\n        self.resize(400, 200)\r\n\r\n        self.progresslabel.setText('Создание временной папки')\r\n        if not os.path.exists('temp'):\r\n            os.mkdir('temp')\r\n        else:\r\n            shutil.rmtree('temp'), os.mkdir('temp')\r\n        self.progressbar.setValue(self.progressbar.value() + 15)\r\n        await asyncio.sleep(0.2)\r\n        pr = 50 / len(levels)\r\n        self.progresslabel.setText('Сохранение информации о точке входа')\r\n        with open('temp/ep.pos', 'w', encoding='UTF-8') as f:\r\n            f.write(f'{levels[0][0].x()} {levels[0][0].y()}')\r\n\r\n        self.progressbar.setValue(self.progressbar.value() + 2)\r\n        await asyncio.sleep(0.2)\r\n        for i, level in enumerate(levels[1:]):\r\n            self.progresslabel.setText(f'Сохранение информации о уровне {level[1].name}')\r\n            os.mkdir(f'temp/{i}')\r\n            with open(f'temp/{i}/info.txt', 'w', encoding='UTF-8') as f:\r\n                f.writelines('\\n'.join([level[1].name, level[1].desc, f'{level[0].x()} {level[0].y()}']))\r\n            await asyncio.sleep(1)\r\n            self.progresslabel.setText(f'Сохранение изображений уровня {level[1].name}')\r\n            os.mkdir(f'temp/{i}/images')\r\n            for j, image in enumerate(level[1].images):\r\n                file = QtCore.QFile(f'temp/{i}/images/{j}.png')\r\n                file.open(QtCore.QIODevice.OpenModeFlag.ReadWrite)\r\n                file.write(image)\r\n                file.close()\r\n            await asyncio.sleep(0.2)\r\n            os.mkdir(f'temp/{i}/memorials')\r\n            for n, memorial in enumerate(level[1].memorials):\r\n                self.progresslabel.setText(f'Сохранение информации о мемориале {memorial.name} уровня {level[1].name}')\r\n                os.mkdir(f'temp/{i}/memorials/{n}')\r\n                with open(f'temp/{i}/memorials/{n}/info.txt', 'w', encoding='UTF-8') as f:\r\n                    f.writelines('\\n'.join([memorial.name, memorial.desc]))\r\n                await asyncio.sleep(0.2)\r\n                self.progresslabel.setText(\r\n                    f'Сохранение изображений предпросмотра мемориала и пазла {memorial.name} уровня {level[1].name}')\r\n                file = QtCore.QFile(f'temp/{i}/memorials/{n}/images/preview.png')\r\n                file.open(QtCore.QIODevice.OpenModeFlag.ReadWrite)\r\n                file.write(memorial.preview)\r\n                file.close()\r\n                file = QtCore.QFile(f'temp/{i}/memorials/{n}/images/puzzle.png')\r\n                file.open(QtCore.QIODevice.OpenModeFlag.ReadWrite)\r\n                file.write(memorial.preview)\r\n                file.close()\r\n                await asyncio.sleep(0.2)\r\n                self.progresslabel.setText(f'Сохранение изображений мемориала {memorial.name} уровня {level[1].name}')\r\n                os.mkdir(f'temp/{i}/memorials/{n}/images')\r\n                for z, image in enumerate(memorial.images):\r\n                    file = QtCore.QFile(f'temp/{i}/memorials/{n}/images/{z}.png')\r\n                    file.open(QtCore.QIODevice.OpenModeFlag.ReadWrite)\r\n                    file.write(image)\r\n                    file.close()\r\n                await asyncio.sleep(0.2)\r\n                self.progresslabel.setText(\r\n                    f'Сохранение элементов пазла и их расположения мемориала {memorial.name} уровня {level[1].name}')\r\n                s = ''\r\n                os.mkdir(f'temp/{i}/memorials/{n}/images/puzzle')\r\n                for p in range(len(memorial.puzzleparts)):\r\n                    for ind, part in enumerate(memorial.puzzleparts[p]):\r\n                        part.save(f'temp/{i}/memorials/{n}/images/puzzle/{p}_{ind}.png')\r\n                        s += f'{p}_{ind}.png '\r\n                    s += '\\n'\r\n\r\n                with open(f'temp/{i}/memorials/{n}/images/puzzle/matrix.txt', 'w') as f:\r\n                    f.write(s)\r\n\r\n            self.progressbar.setValue(int(self.progressbar.value() + pr))\r\n        await asyncio.sleep(0.2)\r\n        self.progresslabel.setText('Упаковка уровня в архив')\r\n        archive = shutil.make_archive(self.dir.split('/')[-1], 'zip', str(getabspath('temp')))\r\n        shutil.move(str(getabspath(archive)), self.dir)\r\n        self.progressbar.setValue(100)\r\n        self.progresslabel.setText('Готово')\r\n        self.setLayout(self.donelout)\r\n\r\n\r\n\r\nclass DClickImgLabel(QLabel):\r\n    clicked = pyqtSignal()\r\n\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.setMouseTracking(True)\r\n        self.setStyleSheet(imgqss)\r\n\r\n    def mousePressEvent(self, a0):\r\n        if self.styleSheet() == imgqss.replace(\"black\", \"red\"):\r\n            self.setStyleSheet(imgqss)\r\n        self.clicked.emit()\r\n\r\n\r\nclass MainWindow(QMainWindow):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.setWindowTitle(\"Создание уровней\")\r\n        self.cw = CentralWidget()\r\n        self.initialize()\r\n\r\n    def initialize(self):\r\n        self.cw.initialize()\r\n        self.resize(1280, 720)\r\n        self.setCentralWidget(self.cw)\r\n        self.show()\r\n\r\n\r\napp = QApplication([])\r\nloop = QEventLoop(app)\r\nasyncio.set_event_loop(loop)\r\nwindow = MainWindow()\r\nwith loop:\r\n    loop.run_forever()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/LevelCreatorQT/source.py b/LevelCreatorQT/source.py
--- a/LevelCreatorQT/source.py	(revision fb231234bd9532486b0cca523e0d2d9f4f208944)
+++ b/LevelCreatorQT/source.py	(date 1736779255014)
@@ -28,7 +28,7 @@
             font-size: 14px;         /* Размер шрифта */
             font-weight: bold;       /* Жирный шрифт */
         }
-        
+
         QLabel:hover {
             background-color: gray;  /* Фон серый при наведении */
         }
@@ -46,11 +46,11 @@
             border-radius: 12px;
             transition: background-color 0.3s ease;
         }
-        
+
         QPushButton:hover {
             background-color: blue;
         }
-        
+
         QPushButton:pressed {
             background-color: black;
         }
@@ -64,11 +64,11 @@
             padding: 10px 20px;
             font-weight: bold;
         }
-        
+
         QPushButton:hover {
             background-color: #c0c0c0;
         }
-        
+
         QPushButton:pressed {
             background-color: #a0a0a0;
         }
@@ -363,7 +363,8 @@
         self.nextbtn.setStyleSheet(buttonqss)
         self.nextbtn.setFixedSize(100, 50)
         self.nextbtn.clicked.connect(self.saveData)
-        self.images = [[DClickImgLabel(), QPixmap(), False] for _ in range(4)]
+        self.images = [[DClickImgLabel(), QPixmap(), False, None] for _ in
+                       range(4)]  # Добавлено хранение оригинального изображения
         self.lout = QHBoxLayout()
         self.objlout = QVBoxLayout()
         self.mimageslout = QVBoxLayout()
@@ -405,15 +406,17 @@
         for img in self.images:
             if not img[2]:
                 if type == "file":
-                    img[1].load(image)
+                    img[3] = QPixmap(image)  # Сохраняем оригинальное изображение
+                    img[1] = img[3].scaled(300, 150, Qt.AspectRatioMode.KeepAspectRatio,
+                                           Qt.TransformationMode.SmoothTransformation)  # Масштабируем для отображения
                 elif type == "buffer":
-                    img[1].loadFromData(image)
-                img[1] = img[1].scaled(300, 150, Qt.AspectRatioMode.KeepAspectRatio,
-                                       Qt.TransformationMode.SmoothTransformation)
+                    img[3] = QPixmap()
+                    img[3].loadFromData(image)
+                    img[1] = img[3].scaled(300, 150, Qt.AspectRatioMode.KeepAspectRatio,
+                                           Qt.TransformationMode.SmoothTransformation)
                 img[0].setPixmap(img[1])
                 img[0].setFixedSize(img[1].size())
                 img[2] = True
-                img[0].setAlignment(Qt.AlignmentFlag.AlignLeft)
                 img[0].show()
                 if self.images.index(img) == 3:
                     img[0].setStyleSheet("")
@@ -470,10 +473,10 @@
             self.levelData.images.clear()
             for image in self.images:
                 if image[2]:
-                    pixmap = image[1]
+                    original_pixmap = image[3]  # Используем оригинальное изображение
                     buffer = QtCore.QBuffer()
                     buffer.open(QtCore.QIODevice.OpenModeFlag.ReadWrite)
-                    pixmap.save(buffer, "PNG")
+                    original_pixmap.save(buffer, "PNG")
                     self.levelData.images.append(buffer.data())
                     buffer.close()
 
@@ -513,15 +516,20 @@
     def addImage(self, image, type="file"):
         pixmap = QPixmap()
         label = DClickImgLabel()
-        pixmap.loadFromData(image.preview) if type == "class" else pixmap.load(image)
-        pixmap = pixmap.scaled(400, 300, Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation)
+        if type == "class":
+            pixmap.loadFromData(image.preview)
+        else:
+            pixmap.load(image)
+        scaled_pixmap = pixmap.scaled(400, 300, Qt.AspectRatioMode.KeepAspectRatio,
+                                      Qt.TransformationMode.SmoothTransformation)
+        label.setPixmap(scaled_pixmap)
         if not self.memorials:
-            label.setPixmap(pixmap)
-            self.memorials.append([label, Memorial(image) if type == 'file' else image, False])
+            self.memorials.append([label, Memorial(image) if type == 'file' else image, False,
+                                   pixmap])  # Сохраняем оригинальное изображение
         else:
-            for i, (label, memorial, is_temp) in enumerate(self.memorials):
+            for i, (label, memorial, is_temp, _) in enumerate(self.memorials):
                 if is_temp:
-                    label.setPixmap(pixmap)
+                    label.setPixmap(scaled_pixmap)
                     if type == 'file':
                         buffer = QtCore.QBuffer()
                         buffer.open(QtCore.QIODevice.OpenModeFlag.ReadWrite)
@@ -529,7 +537,7 @@
                         image = buffer.data()
                         buffer.close()
 
-                    self.memorials[i][1:] = Memorial(image) if type == 'file' else image, False
+                    self.memorials[i][1:] = Memorial(image) if type == 'file' else image, False, pixmap
                     self.memorials[i][0].clicked.disconnect()
                     self.memorials[i][0].clicked.connect(lambda: MemorialEditorWidget(self.memorials[i][1]).exec())
 
@@ -538,10 +546,11 @@
     def addTempImage(self):
         img_label = DClickImgLabel()
         pixmap = QPixmap(getabspath("addmem.png"))
-        pixmap = pixmap.scaled(400, 300, Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation)
-        img_label.setPixmap(pixmap)
+        scaled_pixmap = pixmap.scaled(400, 300, Qt.AspectRatioMode.KeepAspectRatio,
+                                      Qt.TransformationMode.SmoothTransformation)
+        img_label.setPixmap(scaled_pixmap)
         img_label.show()
-        self.memorials.append([img_label, pixmap, True])
+        self.memorials.append([img_label, pixmap, True, None])
         row = (len(self.memorials) - 1) // 2
         col = (len(self.memorials) - 1) % 2
         self.grid_layout.addWidget(img_label, row, col,
@@ -585,7 +594,8 @@
         self.savebtn.setStyleSheet(buttonqss)
         self.savebtn.setFixedSize(150, 50)
         self.savebtn.clicked.connect(self.saveData)
-        self.images = [[DClickImgLabel(), QPixmap(), False] for _ in range(4)]
+        self.images = [[DClickImgLabel(), QPixmap(), False, None] for _ in
+                       range(4)]  # Добавлено хранение оригинального изображения
         self.lout = QHBoxLayout()
         self.objlout = QVBoxLayout()
         self.mimageslout = QVBoxLayout()
@@ -638,11 +648,14 @@
         for img in self.images:
             if not img[2]:
                 if type == "file":
-                    img[1].load(image)
+                    img[3] = QPixmap(image)  # Сохраняем оригинальное изображение
+                    img[1] = img[3].scaled(300, 150, Qt.AspectRatioMode.KeepAspectRatio,
+                                           Qt.TransformationMode.SmoothTransformation)  # Масштабируем для отображения
                 elif type == "buffer":
-                    img[1].loadFromData(image)
-                img[1] = img[1].scaled(300, 150, Qt.AspectRatioMode.KeepAspectRatio,
-                                       Qt.TransformationMode.SmoothTransformation)
+                    img[3] = QPixmap()
+                    img[3].loadFromData(image)
+                    img[1] = img[3].scaled(300, 150, Qt.AspectRatioMode.KeepAspectRatio,
+                                           Qt.TransformationMode.SmoothTransformation)
                 img[0].setPixmap(img[1])
                 img[0].setFixedSize(img[1].size())
                 img[2] = True
@@ -735,10 +748,10 @@
             self.memorial.images.clear()
             for image in self.images:
                 if image[2]:
-                    pixmap = image[1]
+                    original_pixmap = image[3]  # Используем оригинальное изображение
                     buffer = QtCore.QBuffer()
                     buffer.open(QtCore.QIODevice.OpenModeFlag.ReadWrite)
-                    pixmap.save(buffer, "PNG")
+                    original_pixmap.save(buffer, "PNG")
                     self.memorial.images.append(buffer.data())
                     buffer.close()
 
